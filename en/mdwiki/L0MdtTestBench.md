# L0MdtTestBench
We propose to use a VHDL top-level test bench for the user logic in the L0MDT.  More than that, we propose a generic "testbench builder" which can support any VHDL DUT entity which meets certain criteria.

First, each UUT block must receive both of the following types on top-level ports.  These signals are initially generated by the testbench itself according to configuration parameters.

```
  type l0mdt_control_rt is record       -- basic control signals to all blocks
    clk   : std_logic;                  -- pipeline clock
    rst_n : std_logic;                  -- active low reset (min 8 clk)
    bx    : std_logic;                  -- bunch crossing strobe
  end record control;

  type l0mdt_ttc_rt is record           -- Trigger, Timing, Control
    bcr : std_logic;                    -- LHC bunch count reset (BC0)
    ocr : std_logic;                    -- LHC orbit count reset
    ecr : std_logic;                    -- ATLAS event number reset
    l0a : std_logic;                    -- level 0 accept trigger
    l1a : std_logic;                    -- level 1 accept trigger (optional)
  end record ttc;
```

A few generics are required for each top-level block:

```
  CLOCK_PER_BX : number of pipeline clocks per LHC BX
```

The test bench builder will create a "reader" for each top-level port or group of ports according to a recipe.  The recipes will specify configuration parameters such as these:

 * Orbit/BX clock triggered -- each input vector specifies (orbit, BX)
 * Pipeline clock triggered -- each input vector specifies a pipeline clock tick
 * For each port, name of an L0MDT defined type appearing in [l0mdt_buses_types_pkg.vhd](https://gitlab.cern.ch/atlas-tdaq-phase2-l0mdt-electronics/dataformats/-/blob/master/l0mdt_buses_types_pkg.vhd) ([local](http://gauss.bu.edu/svn/atlas-phase-2-muon-upgrade.firmware/tools/L0MDT_textio/l0mdt_buses_types_pkg.vhd))
 * For each port, a set of input values to assert when there is no data present on the port ("idle" pattern)
 * The file name to be associated with the port

The "reader" will open the specified file, and expect to read input vectors presented as one line per vector with space-separated hex integers for each data item.  Hex values must contain the correct number of digits (rounded up to next multiple of 4).  For nested types, a "flattened" list of data items is expected.

The hex read/write is a bit problematic, as the required features are pretty much broken before VHDL 2008.  Here are the hacks to get around this:

The HREAD, HWRITE functions work but fail if the target vector is not a multiple of 4 bits.  Use a short function to round the length up to 4 for temporary vectors for each element:

```
  -- round up vector length to multiple of 4
  function len4r(len : integer) return integer is
  begin
    return len + (3-((len-1) mod 4));
  end len4r;
```

### Rethinking VHDL parsing

Currently the ports we need to support are either `_avt` (array of vector type) or `_art` (array of record type).  For example:

```
    -- Segments in from neighbor
    plus_neighbor_segments_i  : in SF_avt (c_NUM_SF_INPUTS-1 downto 0);
    minus_neighbor_segments_i : in SF_avt (c_NUM_SF_INPUTS-1 downto 0);
```

```
  constant SF_LEN : integer := 128;
  subtype SF_vt is std_logic_vector(SF_LEN-1 downto 0);
  type SF_avt is array (integer range <>) of SF_vt;
```

### Problems with Arrays

How to handle ports with arrays?  Need to aggregate all vectors with same time and different array elements in the TB itself, then assert them all with DV set on only those with matching vectors.  This can't be handled in the textio package.  So for now no array types handled in textio?
